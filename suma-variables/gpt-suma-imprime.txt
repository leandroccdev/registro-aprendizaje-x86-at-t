.section .data
    a:     .int 10
    b:     .int 5
    c:     .int 0

    buffer: .space 12        # Espacio para el número convertido + \n + null
    newline: .asciz "\n"

.section .text
    .globl _start

_start:
    # Sumar a + b → c
    movl a, %eax
    addl b, %eax
    movl %eax, c             # Guardamos resultado

    # Convertir número (en eax) a string en 'buffer'
    movl %eax, %ebx          # Número → ebx
    movl $buffer+11, %edi    # apuntamos al final del buffer
    movb $0, (%edi)          # null terminator
    decl %edi                # espacio para dígito

convert_loop:
    movl $10, %ecx
    xorl %edx, %edx
    divl %ecx                # divide edx:eax / ecx → resultado en eax, resto en edx
    addb $'0', %dl           # convierte resto a ASCII
    movb %dl, (%edi)         # guarda carácter
    decl %edi
    test %eax, %eax
    jnz convert_loop

    incl %edi                # apunta al primer dígito

    # Agrega newline al final (opcional)
    movb $'\n', buffer+11
    movb $0, buffer+12

    # Escribir buffer por stdout
    movl $4, %eax            # syscall write
    movl $1, %ebx            # fd = 1 (stdout)
    movl %edi, %ecx          # puntero al string
    movl $buffer+11, %edx
    subl %edi, %edx          # longitud = fin - inicio
    addl $1, %edx            # incluye el newline
    int $0x80

    # Salir
    movl $1, %eax
    xorl %ebx, %ebx
    int $0x80
